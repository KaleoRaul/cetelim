import { Component } from 'react';
import PropTypes from 'prop-types';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var NODE_ENV = process.env.NODE_ENV;

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

var invariant_1 = invariant;

var asArray = function asArray(input) {
  var output;

  if (!Array.isArray(input)) {
    output = [input];
  } else {
    output = input;
  }

  return output;
};

var Trap =
/*#__PURE__*/
function (_Component) {
  _inherits(Trap, _Component);

  function Trap() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Trap);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Trap)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "state", {
      trapped: false
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "preventDefaultHelper", function (e, nextTrapped) {
      var preventDefault = _this.props.preventDefault;
      var trapped = _this.state.trapped;

      if (trapped !== nextTrapped && preventDefault) {
        e.preventDefault();
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleEvent", function (e) {
      var trapped = _this.ref.contains(e.target);

      _this.preventDefaultHelper(e, trapped);

      _this.setState({
        trapped: trapped
      });
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleFocusEvent", function (e) {
      var trapped = _this.ref.contains(e.target);

      _this.preventDefaultHelper(e, trapped);

      if (trapped) {
        _this.setState({
          trapped: true
        });
      }
    });

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "handleBlurEvent", function (e) {
      var trapped = _this.ref.contains(e.target);

      _this.preventDefaultHelper(e, trapped);

      if (!trapped) {
        _this.setState({
          trapped: false
        });
      }
    });

    return _this;
  }

  _createClass(Trap, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var _this$props = this.props,
          event = _this$props.event,
          on = _this$props.on,
          off = _this$props.off;
      invariant_1(this.ref && this.ref.contains, "A ref is required, did you forgot to use it?");

      if (on && off) {
        asArray(on).forEach(function (evt) {
          document.addEventListener(evt, _this2.handleFocusEvent, {
            detail: {
              reactTrap: true
            }
          });
        });
        asArray(off).forEach(function (evt) {
          document.addEventListener(evt, _this2.handleBlurEvent, {
            detail: {
              reactTrap: true
            }
          });
        });
      } else {
        asArray(event).forEach(function (evt) {
          document.addEventListener(evt, _this2.handleEvent, {
            detail: {
              reactTrap: true
            }
          });
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this3 = this;

      var _this$props2 = this.props,
          event = _this$props2.event,
          on = _this$props2.on,
          off = _this$props2.off;

      if (on && off) {
        asArray(on).forEach(function (evt) {
          document.removeEventListener(evt, _this3.handleFocusEvent);
        });
        asArray(off).forEach(function (evt) {
          document.removeEventListener(evt, _this3.handleBlurEvent);
        });
      } else {
        asArray(event).forEach(function (evt) {
          document.removeEventListener(evt, _this3.handleEvent);
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var children = this.props.children;
      var trapped = this.state.trapped;
      invariant_1(typeof children === "function", 'The "children" prop must be a function');
      return children(trapped, function (ref) {
        return _this4.ref = ref;
      });
    }
  }]);

  return Trap;
}(Component);

_defineProperty(Trap, "propTypes", {
  /** children as function: (trapped, ref) => <YourComponent ... /> */
  children: PropTypes.func.isRequired,

  /** DOM event to habdle both in and out events */
  event: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),

  /** DOM event just for the focus, working in combination with the off prop  */
  on: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),

  /** DOM event just for the blur, working in combination with the on prop  */
  off: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),

  /** This will prevent the default (only if the state has changed) */
  preventDefault: PropTypes.bool
});

_defineProperty(Trap, "defaultProps", {
  event: "click",
  on: "",
  off: "",
  preventDefault: false
});

export default Trap;
//# sourceMappingURL=index.es.js.map
